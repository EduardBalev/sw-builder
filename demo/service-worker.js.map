{
  "version": 3,
  "sources": ["../src/.temp.service-worker.bundle.ts"],
  "sourcesContent": ["\n      /* Service Worker generated by sw-builder */\n      (() => {\n        const SW = self;\n        \n    // Entry point content\n    \n    \n  /// <reference lib=\"webworker\" />\n  \n  declare const self: ServiceWorkerGlobalScope;\n  declare const CONFIG: { debug: boolean };\n  CONFIG.debug = true;\n  \n  // Initialize hooks container\n  const HOOKS: Record<string, Function> = {};\n\n    function registerEvent(eventName, fn) {\n  if (typeof fn !== 'function') {\n    return;\n  }\n\n  console.log('Registering event successfully: ', eventName);\n  \n  SW.addEventListener(eventName, (event) => {\n    console.log('Event triggered: ', eventName, event);\n\n    fn(event);\n  });\n}\n\n  \n\n    // Inlined dependencies and source content\n    ;\n;\n\ninterface PageLoadedEventData {\n  action: 'pageLoaded';\n  staticPatterns: RegExp[];\n  disableStaticCache: boolean;\n  disableDynamicCache: boolean;\n  version: string;\n  checkVersion: boolean;\n}\n\ninterface UpdateAllEndpointsEventData {\n  action: 'updateAllEndpoints';\n}\n\ninterface NotifyAllEventData {\n  action: 'notifyAll';\n  event: NotifyData;\n}\n\ntype ExtendableEventData = PageLoadedEventData | UpdateAllEndpointsEventData | NotifyAllEventData;\n\ninterface NotifyData {\n  action: string;\n  data: unknown;\n}\n\nconst CACHE_NAME_STATIC = 'static-cache';\nconst CACHE_NAME_API = 'api-cache';\nconst CACHE_HEADER_NAME = 'CacheName';\nconst CACHE_LIST = new Map<\n  string,\n  {\n    name: string;\n    ttl: number;\n    updateTimestamp?: number;\n  }\n>();\n\nlet APP_VERSION: string = null;\nlet DISABLE_STATIC_CACHE = false;\nlet DISABLE_DYNAMIC_CACHE = false;\n\nconst onInstall: InstallHandler = () => {\n  SW.skipWaiting();\n};\n\nconst onActivate: ActivateHandler = (event) => {\n  event.waitUntil(Promise.all([SW.clients.claim(), clearAllAPICache()]));\n};\n\nconst onMessage: MessageHandler = (event) => {\n  /**\n   * Triggered when the main page signals that it has loaded.\n   */\n  if (event.data.action === 'pageLoaded') {\n    const staticPatterns = event.data.staticPatterns;\n    DISABLE_STATIC_CACHE = !!event.data.disableStaticCache;\n    DISABLE_DYNAMIC_CACHE = !!event.data.disableDynamicCache;\n    APP_VERSION = event.data.version;\n\n    if (staticPatterns && !DISABLE_STATIC_CACHE) {\n      addStaticPatterns(staticPatterns);\n    }\n\n    if (DISABLE_STATIC_CACHE) {\n      clearAllStaticCache();\n    }\n\n    clearAllAPICache();\n    return;\n  }\n\n  /**\n   * Triggered when all endpoints need to be updated.\n   */\n  if (event.data.action === 'updateAllEndpoints') {\n    clearAllAPICache();\n    return;\n  }\n\n  /**\n   * Triggered when all endpoints need to be updated.\n   */\n  if (event.data.action === 'notifyAll') {\n    sendEvent(event.data.event);\n    return;\n  }\n};\n\nconst onFetch: FetchHandler = (event) => {\n  const requestUrl = new URL(event.request.url);\n  const ignore = getRequestHeader(event.request, 'CacheIgnore');\n  const cacheName = getRequestHeader(event.request, CACHE_HEADER_NAME);\n\n  if (ignore) {\n    return;\n  }\n\n  // Check if the request is an HTML page\n  const isHtmlRequest =\n    event.request.headers.get('Accept')?.includes('text/html') || requestUrl.pathname.endsWith('.html');\n\n  if (isHtmlRequest || /^chrome-extension\\:|^ws\\:|\\/runtime\\./.test(event.request.url)) {\n    return;\n  }\n\n  if (requestUrl.pathname.includes('/api/') && !DISABLE_DYNAMIC_CACHE) {\n    catchCashableRequests(event.request).then(() => {\n      if (CACHE_LIST.has(cacheName)) {\n        event.respondWith(handleAPICache(event.request, cacheName));\n      }\n    });\n\n    return;\n  }\n\n  if (staticResourcesPattern.test(event.request.url) && event.request.method === 'GET' && !DISABLE_STATIC_CACHE) {\n    event.respondWith(handleStaticCache(event.request));\n    return;\n  }\n};\n\nlet staticResourcesPattern = new RegExp('');\nfunction addStaticPatterns(sources: RegExp[]) {\n  staticResourcesPattern = new RegExp(sources.map((regex) => regex.source).join('|'));\n}\n\nfunction sendEvent(event: NotifyData) {\n  SW.clients.matchAll().then((clients) => {\n    clients.forEach((client) => {\n      client.postMessage(event);\n    });\n  });\n}\n\nasync function catchCashableRequests(request: Request) {\n  if (request.headers.get('Cashable') === 'true') {\n    const name = request.headers.get(CACHE_HEADER_NAME);\n    const ttl = request.headers.get('CacheTTL');\n    const updateFor = request.headers.get('CacheUpdateFor');\n\n    if (name && !CACHE_LIST.has(name)) {\n      CACHE_LIST.set(name, {\n        name,\n        ttl: +ttl,\n      });\n    }\n\n    if (updateFor) {\n      const names = updateFor.split(',');\n\n      if (names && names.length) {\n        await updateEndpoints(names);\n      }\n    }\n  }\n}\n\n/**\n * Handle API Cache\n * @param {Request} request - The request to be handled.\n * @returns {Promise<Response>} A Promise that resolves to the cached or network response.\n */\nasync function handleStaticCache(request: Request) {\n  const cache = await caches.open(CACHE_NAME_STATIC);\n  const cachedResponse = await cache.match(request);\n\n  if (cachedResponse) {\n    return cachedResponse;\n  }\n\n  const networkResponse = await fetch(request);\n  cache.put(request, networkResponse.clone());\n\n  return networkResponse;\n}\n/**\n * Handle API Cache\n * @param {Request} request - The request to be handled.\n * @param {string} cacheName - The name of the cache.\n * @returns {Promise<Response>} A Promise that resolves to the cached or network response.\n */\nasync function handleAPICache(request: Request, cacheName: string) {\n  const cache = await caches.open(CACHE_NAME_API);\n  const cachedResponse = await cache.match(request);\n  const meta = CACHE_LIST.get(cacheName);\n  const now = new Date().getTime();\n  const updateTimestamp = meta.updateTimestamp ?? now;\n  const isManuallyUpdated = updateTimestamp < now;\n\n  if (cachedResponse && !isManuallyUpdated && !isCacheExpired(cachedResponse)) {\n    return cachedResponse;\n  }\n\n  if (cachedResponse) {\n    cache.delete(request);\n    meta.updateTimestamp = null;\n  }\n\n  const networkResponse = await fetchAndCache(request);\n  cache.put(request, networkResponse.clone());\n\n  return networkResponse;\n}\n\n/**\n * Check if Cache is Expired\n * @param {Response} cachedResponse - The cached response to check for expiration.\n * @returns {boolean} True if the cache is expired, false otherwise.\n */\nfunction isCacheExpired(cachedResponse: Response) {\n  if (cachedResponse == null) {\n    return false;\n  }\n\n  const cachedMetadata = getCachedMetadata(cachedResponse);\n\n  // Check if the cache has expired based on the TTL property\n  if (cachedMetadata && cachedMetadata.expired) {\n    const currentTime = new Date().getTime();\n    const expiredTime = cachedMetadata.expired;\n\n    return expiredTime < currentTime;\n  }\n\n  // If there is no expired, consider the cache as not expired\n  return false;\n}\n\n/**\n * Update Endpoints in Cache List\n * @param {string[]} names - The array of endpoint names to update.\n */\nasync function updateEndpoints(names: string[]) {\n  names.forEach((name) => {\n    const data = CACHE_LIST.get(name);\n    if (data) {\n      data.updateTimestamp = new Date().getTime();\n    }\n  });\n\n  const cache = await caches.open(CACHE_NAME_API);\n\n  (await cache.keys()).forEach((req) => {\n    const cacheName = req.headers.get(CACHE_HEADER_NAME);\n    if (cacheName && names.includes(cacheName)) {\n      cache.delete(req);\n    }\n  });\n}\n\n/**\n * Get Request Header\n * @param {Request} request - The request to extract headers from.\n * @param {string} headerName - The name of the header to retrieve.\n * @returns {string | null} The value of the header or null if not found.\n */\nfunction getRequestHeader(request: Request, headerName: string) {\n  const headers = request.headers;\n  let result = null;\n  headers.forEach((value, name) => {\n    if (name.toLowerCase() === headerName.toLowerCase()) {\n      result = value;\n    }\n  });\n  return result;\n}\n\n/**\n * Fetch and Cache Response\n * @param {RequestInfo} request - The request to fetch and cache.\n * @returns {Promise<Response>} A Promise that resolves to the response with added metadata.\n */\nasync function fetchAndCache(request) {\n  try {\n    const response = await fetch(request);\n    const cacheName = getRequestHeader(request, CACHE_HEADER_NAME);\n\n    // Check if the response is valid before caching\n    if (!response || response.status !== 200) {\n      return response;\n    }\n\n    // Store expired in cache metadata\n    const cacheMetadata = {\n      expired: new Date().getTime() + CACHE_LIST.get(cacheName)?.ttl || 0,\n    };\n    const _response = response.clone();\n\n    // Attach metadata to the response headers\n    const headers = new Headers(_response.headers);\n    headers.append('X-Cache-Metadata', JSON.stringify(cacheMetadata));\n\n    const responseWithMetadata = new Response(_response.body, {\n      ..._response,\n      headers: headers,\n    });\n\n    return responseWithMetadata;\n  } catch (error) {\n    throw error;\n  }\n}\n\n/**\n * Get Cached Metadata from Response\n * @param {Response} cachedResponse - The cached response to extract metadata from.\n * @returns {Object | null} The parsed metadata object or null if not found.\n */\nfunction getCachedMetadata(cachedResponse) {\n  // Extract the metadata from the cached response headers\n  const metadataString = cachedResponse.headers.get('X-Cache-Metadata');\n  return metadataString ? JSON.parse(metadataString) : null;\n}\n\n/**\n * Clear API Cache\n * @param {RegExp} exclude - The name of the cache to clear.\n * @returns {Promise<void>} A Promise that resolves once the cache is cleared.\n */\nfunction clearApiCache(exclude) {\n  return caches.keys().then((cacheNames) => {\n    if (exclude) {\n      cacheNames = cacheNames.filter((name) => !exclude.test(name));\n    }\n    return Promise.all(cacheNames.map((name) => caches.delete(name)));\n  });\n}\n\nasync function clearAllAPICache() {\n  await caches.delete(CACHE_NAME_API);\n  await updateEndpoints(Array.from(CACHE_LIST.keys()));\n}\n\nfunction clearAllStaticCache() {\n  return caches.delete(CACHE_NAME_STATIC).then(() => {});\n}\n\n\n    // Register hooks\n    // Register install event\nregisterEvent(\"install\", onInstall);\n// Register activate event\nregisterEvent(\"activate\", onActivate);\n// Register fetch event\nregisterEvent(\"fetch\", onFetch);\n// Register message event\nregisterEvent(\"message\", onMessage);\n  \n      })();\n    "],
  "mappings": "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",
  "names": []
}

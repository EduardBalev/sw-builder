{
  "version": 3,
  "sources": ["../src/logger.ts", "../src/swScope.ts", "../src/utils.ts", "../src/cache-strategies/api-cache.strategy.ts", "../src/cache-strategies/static-cache.strategy.ts", "../src/consts.ts", "../src/fetchHandlers.ts", "../src/eventListeners.ts", "../src/service-worker.ts"],
  "sourcesContent": ["let __loggerIsEnabled = false;\n\n/**\n * Enables the logger, allowing logs to be printed to the console.\n */\nexport function enableLogger() {\n  __loggerIsEnabled = true;\n}\n\n/**\n * Disables the logger, preventing logs from being printed to the console.\n */\nexport function disableLogger() {\n  __loggerIsEnabled = false;\n}\n\n/**\n * Logs the provided data to the console if logging is enabled.\n *\n * @param {...unknown[]} data - The data to be logged.\n */\nexport function logger(...data: unknown[]) {\n  if (__loggerIsEnabled) {\n    console.log(...data);\n  }\n}\n", "/// <reference lib=\"webworker\" />\n\n/**\n * Casts the global `self` object to the `ServiceWorkerGlobalScope` type.\n *\n * In TypeScript, the `self` object, which represents the global scope in a service worker, is by default typed as `Window & typeof globalThis`.\n * This means that TypeScript will treat `self` as a standard window object, not as a service worker global scope. To use service worker-specific\n * properties like `clients`, `skipWaiting()`, or event listeners such as `onfetch`, we need to cast `self` to the correct type.\n *\n * This ensures that the service worker-specific APIs and properties are available in a type-safe manner without TypeScript errors.\n *\n * @constant {ServiceWorkerGlobalScope} swScope - A correctly typed reference to the service worker's global scope.\n */\nexport const swScope = self as unknown as ServiceWorkerGlobalScope;\n", "import { SwCacheList } from \"./interfaces/cache\";\nimport { SWConfig } from \"./interfaces/config\";\nimport { NotifyData } from \"./interfaces/notify-data\";\nimport { logger } from \"./logger\";\nimport { swScope } from \"./swScope\";\n\n/**\n * Retrieves the value of a specific header from a given request.\n *\n * @param {Request} request - The request object containing headers.\n * @param {string} headerName - The name of the header to retrieve.\n * @returns {string | null} The value of the specified header, or null if the header is not found.\n */\nexport function getRequestHeader(\n  request: Request,\n  headerName: string,\n): string | null {\n  return request?.headers?.get(toCapitalizedString(headerName));\n}\n\n/**\n * Sends a specified event to all connected clients (e.g., browser tabs or windows controlled by the service worker).\n *\n * @param {NotifyData} event - The event data to be sent to each connected client.\n */\nexport async function sendEvent(event: NotifyData) {\n  // Log the event that is being sent\n  logger(\"Sending event from Service Worker: \", event);\n\n  try {\n    // Get all connected clients (e.g., browser tabs or windows controlled by the service worker)\n    const clients = await swScope.clients.matchAll();\n\n    logger(`Found ${clients.length} clients to send the event to.`);\n\n    // Send the event to each client\n    for (let i = 0; i < clients.length; i++) {\n      logger(`Sending event to client: ${clients[i].id}`);\n      clients[i].postMessage(event);\n    }\n\n    logger(\"Event sent to all clients.\");\n  } catch (error) {\n    logger(\"Error sending event to clients:\", error);\n  }\n}\n\n/**\n * Processes cacheable requests by checking headers and updating the cache if needed.\n *\n * @param {Request} request - The network request to check for cacheability.\n * @param {SwCacheList} cache - The cache list to store and update cache entries.\n * @param {SWConfig} config - The configuration containing header names and cache settings.\n * @returns {Promise<void>} A promise that resolves after processing the cache logic.\n */\nexport async function catchCashableRequests(\n  request: Request,\n  cache: SwCacheList,\n  config: SWConfig,\n): Promise<void> {\n  // Cache header values to avoid repeated lookups\n  const useCache = request.headers.get(config.CACHE_USE_CACHE_NAME);\n  const name = request.headers.get(config.CACHE_HEADER_NAME);\n  const ttl = request.headers.get(config.CACHE_TTL_NAME);\n  const updateFor = request.headers.get(config.CACHE_DELETE_NAME);\n\n  // Logging initial check for cache usage\n  logger(`Checking if request should use cache: ${useCache}`);\n\n  // If caching is not enabled, return early\n  if (useCache !== \"true\") {\n    logger(`Caching not enabled for this request.`);\n    return;\n  }\n\n  logger(`Processing request for cacheable content.`);\n\n  // Add new cache entry if not already present\n  if (name && !cache.has(name)) {\n    cache.set(name, {\n      name,\n      ttl: Number(ttl), // Convert ttl to a number\n    });\n    logger(`Cache entry added: ${name} with TTL: ${ttl}`);\n  } else if (name) {\n    logger(`Cache entry for ${name} already exists.`);\n  }\n\n  // Update specified endpoints if needed\n  if (updateFor) {\n    const names = updateFor.split(\",\");\n\n    if (names.length > 0) {\n      logger(`Updating cache for the following endpoints: ${names}`);\n      await updateEndpoints(names, cache, config);\n    }\n  }\n}\n\n/**\n * Updates the cache entries by setting the update timestamp and removing expired entries based on provided names.\n *\n * @param {string[]} names - The list of cache entry names to update.\n * @param {SwCacheList} cache - The cache list where the entries are stored.\n * @param {SWConfig} config - The configuration containing cache settings and header names.\n * @returns {Promise<void>} A promise that resolves once all cache entries have been updated and expired entries are deleted.\n */\nexport async function updateEndpoints(\n  names: string[],\n  cache: SwCacheList,\n  config: SWConfig,\n): Promise<void> {\n  const now = Date.now(); // Cache current timestamp to avoid multiple Date object creation\n\n  logger(`Updating endpoints: ${names.join(\", \")}`);\n\n  // Update the timestamp for each endpoint in the cache\n  for (const name of names) {\n    const data = cache.get(name);\n    if (data) {\n      data.updateTimestamp = now;\n      logger(`Updated timestamp for cache entry: ${name}`);\n    } else {\n      logger(`Cache entry not found for: ${name}`);\n    }\n  }\n\n  const cacheInstance = await caches.open(config.CACHE_NAME_API);\n  logger(`Opened cache: ${config.CACHE_NAME_API}`);\n\n  const keys = await cacheInstance.keys(); // Retrieve all cached requests\n  logger(`Retrieved ${keys.length} cached requests`);\n\n  // Delete matching cached requests based on header names\n  const deletePromises = [];\n  for (const req of keys) {\n    const cacheName = req.headers.get(config.CACHE_HEADER_NAME);\n    if (cacheName && names.includes(cacheName)) {\n      logger(`Deleting cache entry for: ${cacheName}`);\n      deletePromises.push(cacheInstance.delete(req));\n    }\n  }\n\n  // Wait for all cache deletions to complete\n  await Promise.all(deletePromises);\n  logger(`Deleted ${deletePromises.length} cache entries`);\n}\n\n/**\n * Fetches a request from the network and caches the response with metadata.\n *\n * @param {Request} request - The network request to fetch.\n * @param {SwCacheList} cache - The cache list where the cache metadata will be stored.\n * @param {SWConfig} config - The configuration containing cache settings and header names.\n * @returns {Promise<Response>} A promise that resolves to the fetched response with cache metadata.\n */\nexport async function fetchAndCache(\n  request: Request,\n  cache: SwCacheList,\n  config: SWConfig,\n): Promise<Response> {\n  try {\n    logger(`Fetching request: ${request.url}`);\n\n    // Fetch the response from the network\n    const response = await fetch(request);\n    const cacheName = getRequestHeader(request, config.CACHE_HEADER_NAME);\n\n    // Check if the response is valid before caching\n    if (!response || response.status !== 200) {\n      logger(\n        `Fetch failed or invalid response for: ${request.url} - Status: ${response?.status}`,\n      );\n      return response;\n    }\n\n    logger(`Fetch successful for: ${request.url}, caching response.`);\n\n    // Get the cache metadata\n    const ttl = cache.get(cacheName)?.ttl || 0;\n    const expiredTimestamp = Date.now() + ttl;\n    const cacheMetadata = { expired: expiredTimestamp };\n\n    // Clone the response to attach metadata\n    const responseWithMetadata = new Response(response.body, {\n      ...response,\n      headers: new Headers(response.headers),\n    });\n\n    // Attach cache metadata to the response headers\n    responseWithMetadata.headers.append(\n      \"X-Cache-Metadata\",\n      JSON.stringify(cacheMetadata),\n    );\n    logger(\n      `Attached cache metadata for: ${request.url}, expires at: ${expiredTimestamp}`,\n    );\n\n    return responseWithMetadata;\n  } catch (error) {\n    logger(`Fetch failed for: ${request.url}`, error);\n    throw error;\n  }\n}\n\n// Helper function to check if a URL matches any string or RegExp pattern\nexport function matchesPattern(\n  url: string,\n  patterns: (string | RegExp)[],\n): boolean {\n  return patterns.some((pattern) => {\n    if (typeof pattern === \"string\") {\n      return url.includes(pattern); // If the pattern is a string, check if the URL contains it\n    } else {\n      return pattern.test(url); // If it's a RegExp, use the test method\n    }\n  });\n}\n\n/**\n * Converts any case string to a pattern where only the first letter of the entire string is capitalized\n * and the rest of the string is in lowercase.\n *\n * @param {string} input - The input string to be converted.\n * @returns {string} The formatted string where only the first letter is capitalized.\n */\nfunction toCapitalizedString(input: string): string {\n  return input.charAt(0).toUpperCase() + input.slice(1).toLowerCase();\n}\n", "import { CacheStrategy, SwCacheList } from \"../interfaces/cache\";\nimport { SWConfig } from \"../interfaces/config\";\nimport { logger } from \"../logger\";\nimport { fetchAndCache, updateEndpoints } from \"../utils\";\n/**\n * Handles caching for API requests.\n *\n * This class provides logic to manage API request caching, including\n * checking the cache, fetching from the network if necessary, and clearing\n * outdated cache entries. It utilizes a cache strategy to serve cached responses\n * efficiently.\n */\nexport class APICacheStrategy implements CacheStrategy {\n  private cacheName: string;\n  private cacheList: SwCacheList;\n  private config: SWConfig;\n\n  /**\n   * Constructs the APICacheStrategy class.\n   *\n   * @param {string} cacheName - The name of the cache used for API requests.\n   * @param {SwCacheList} cacheList - A map of cache metadata used to manage API cache entries.\n   * @param {SWConfig} config - The service worker configuration.\n   */\n  constructor(cacheName: string, cacheList: SwCacheList, config: SWConfig) {\n    this.cacheName = cacheName;\n    this.cacheList = cacheList;\n    this.config = config;\n  }\n\n  /**\n   * Handles an API request by either serving from the cache or fetching from the network.\n   *\n   * @param {Request} request - The API request to be handled.\n   * @returns {Promise<Response>} - The cached response or the network response.\n   */\n  async handle(request: Request): Promise<Response> {\n    const cache = await caches.open(this.config.CACHE_NAME_API);\n    const cachedResponse = await cache.match(request);\n    const meta = this.cacheList.get(this.cacheName);\n    const now = Date.now();\n    const updateTimestamp = meta?.updateTimestamp ?? now;\n    const isManuallyUpdated = updateTimestamp < now;\n\n    logger(`Handling API request for: ${request.url}`);\n\n    // Serve from cache if available and valid\n    if (\n      cachedResponse &&\n      !isManuallyUpdated &&\n      !this.isCacheExpired(cachedResponse)\n    ) {\n      logger(`API Cache hit: ${request.url}`);\n      return cachedResponse;\n    }\n\n    // If the cache is outdated, delete it\n    if (cachedResponse) {\n      logger(`API Cache outdated - deleting cached entry: ${request.url}`);\n      await cache.delete(request);\n      if (meta) {\n        meta.updateTimestamp = null;\n      }\n    }\n\n    // Fetch from network and cache the response\n    logger(`API Cache miss - fetching from network: ${request.url}`);\n    const networkResponse = await fetchAndCache(\n      request,\n      this.cacheList,\n      this.config,\n    );\n    cache.put(request, networkResponse.clone());\n\n    return networkResponse;\n  }\n\n  /**\n   * Clears the API cache and updates all cached endpoints.\n   *\n   * This method deletes the current API cache and forces updates for all\n   * endpoints stored in the cache list.\n   */\n  async clear(): Promise<void> {\n    logger(\"Clearing API cache...\");\n    await caches.delete(this.config.CACHE_NAME_API);\n    await updateEndpoints(\n      Array.from(this.cacheList.keys()),\n      this.cacheList,\n      this.config,\n    );\n    logger(\"API cache cleared and endpoints updated.\");\n  }\n\n  /**\n   * Checks if the cached response has expired.\n   *\n   * @param {Response} cachedResponse - The cached response to check.\n   * @returns {boolean} - True if the cache has expired, false otherwise.\n   */\n  private isCacheExpired(cachedResponse: Response): boolean {\n    const cachedMetadata = this.getCachedMetadata(cachedResponse);\n    const currentTime = Date.now();\n    const expiredTime = cachedMetadata?.expired || 0;\n    const isExpired = expiredTime < currentTime;\n\n    logger(\n      `Cache expiration check for ${cachedResponse.url}: ${isExpired ? \"Expired\" : \"Valid\"}`,\n    );\n    return isExpired;\n  }\n\n  /**\n   * Extracts cache metadata from the cached response headers.\n   *\n   * @param {Response} cachedResponse - The cached response to extract metadata from.\n   * @returns {any} - The parsed metadata or null if no metadata is available.\n   */\n  private getCachedMetadata(cachedResponse: Response): any {\n    const metadataString = cachedResponse.headers.get(\"X-Cache-Metadata\");\n    logger(`Extracting cache metadata for ${cachedResponse.url}`);\n    return metadataString ? JSON.parse(metadataString) : null;\n  }\n}\n", "import { CacheStrategy } from \"../interfaces/cache\";\nimport { logger } from \"../logger\";\n\n/**\n * Handles caching for static resources.\n *\n * This class provides logic to manage static resource caching, including\n * checking the cache for existing resources and fetching from the network\n * if the cache is unavailable. It utilizes a cache strategy to serve static\n * content efficiently.\n */\nexport class StaticCacheStrategy implements CacheStrategy {\n  private cacheName: string;\n\n  /**\n   * Constructs the StaticCacheStrategy class.\n   *\n   * @param {string} cacheName - The name of the cache used for static resources.\n   */\n  constructor(cacheName: string) {\n    this.cacheName = cacheName;\n  }\n\n  /**\n   * Handles a static resource request by either serving from the cache or fetching from the network.\n   *\n   * @param {Request} request - The static resource request to be handled.\n   * @returns {Promise<Response>} - The cached response or the network response.\n   */\n  async handle(request: Request): Promise<Response> {\n    const cache = await caches.open(this.cacheName);\n    const cachedResponse = await cache.match(request);\n\n    logger(`Handling static resource request for: ${request.url}`);\n\n    // Serve from cache if available\n    if (cachedResponse) {\n      logger(`STATIC Cache hit: ${request.url}`);\n      return cachedResponse;\n    }\n\n    // Fetch from network and cache the response\n    logger(`STATIC Cache miss - fetching from network: ${request.url}`);\n    const networkResponse = await fetch(request);\n    cache.put(request, networkResponse.clone());\n\n    logger(`Cached static resource: ${request.url}`);\n    return networkResponse;\n  }\n\n  /**\n   * Clears the static resource cache.\n   *\n   * This method deletes the entire static resource cache associated with the cache name.\n   */\n  async clear(): Promise<void> {\n    logger(`Clearing static cache: ${this.cacheName}`);\n    await caches.delete(this.cacheName);\n    logger(`Static cache cleared: ${this.cacheName}`);\n  }\n}\n", "import { SwCache } from \"./interfaces/cache\";\nimport { SwState } from \"./interfaces/state\";\n\n/**\n * The state object of the service worker, holding the configuration, static resource patterns, and cache entries.\n *\n * @constant {SwState} STATE\n */\nexport const STATE: SwState = {\n  CONFIG: null,\n  STRATEGIES: {\n    apiCache: null,\n    staticCache: null,\n  },\n  CACHE_LIST: new Map<string, SwCache>(),\n};\n", "import { APICacheStrategy } from \"./cache-strategies/api-cache.strategy\";\nimport { StaticCacheStrategy } from \"./cache-strategies/static-cache.strategy\";\nimport { STATE } from \"./consts\";\nimport { SwState } from \"./interfaces/state\";\nimport { logger } from \"./logger\";\nimport { swScope } from \"./swScope\";\nimport {\n  catchCashableRequests,\n  getRequestHeader,\n  matchesPattern,\n} from \"./utils\";\n\n/**\n * Initializes caching strategies and attaches event handlers for the service worker.\n *\n * This function sets up the service worker by creating caching strategies and\n * binding the necessary event listeners such as the `fetch` event listener.\n */\nexport function initFetchHandlers(strategies: SwState[\"STRATEGIES\"]) {\n  logger(\"Initializing caching strategies...\");\n\n  logger(\"Caching strategies initialized successfully.\");\n\n  // Attach fetch event listener and pass strategies\n  swScope.addEventListener(\"fetch\", (event) => {\n    logger(`Fetch event detected for: ${event.request.url}`);\n    handleFetchEvent(event, strategies.apiCache, strategies.staticCache);\n  });\n  logger(\"Fetch event listener attached.\");\n}\n\n/**\n * Handles the fetch event and applies caching strategies based on the request type.\n *\n * @param {FetchEvent} event - The fetch event triggered by the browser.\n * @param {APICacheStrategy} apiCacheStrategy - The strategy used for caching API requests.\n * @param {StaticCacheStrategy} staticCacheStrategy - The strategy used for caching static resources.\n */\nexport function handleFetchEvent(\n  event: FetchEvent,\n  apiCacheStrategy: APICacheStrategy,\n  staticCacheStrategy: StaticCacheStrategy,\n) {\n  const requestUrl = new URL(event.request.url);\n  const ignore = getRequestHeader(\n    event.request,\n    STATE.CONFIG.CACHE_IGNORE_NAME,\n  );\n  const cacheName = getRequestHeader(\n    event.request,\n    STATE.CONFIG.CACHE_HEADER_NAME,\n  );\n\n  logger(`Handling fetch event for: ${event.request.url}`);\n\n  // Ignore requests based on the CACHE_IGNORE_NAME header\n  if (ignore) {\n    logger(\n      `Request ignored due to CACHE_IGNORE_NAME header: ${event.request.url}`,\n    );\n    return;\n  }\n\n  // Check exclusion patterns from config (e.g., Chrome extensions, WebSocket)\n  if (matchesPattern(requestUrl.href, STATE.CONFIG.EXCLUDE_PATTERNS)) {\n    logger(`Request excluded: ${event.request.url}`);\n    return;\n  }\n\n  // Handle API caching for dynamic content based on API patterns in the config\n  if (\n    matchesPattern(requestUrl.pathname, STATE.CONFIG.API_PATTERNS) &&\n    !STATE.CONFIG.DISABLE_DYNAMIC_CACHE\n  ) {\n    logger(`Processing API request: ${event.request.url}`);\n\n    catchCashableRequests(event.request, STATE.CACHE_LIST, STATE.CONFIG).then(\n      () => {\n        if (STATE.CACHE_LIST.has(cacheName)) {\n          logger(`Serving API response from cache: ${cacheName}`);\n          event.respondWith(apiCacheStrategy.handle(event.request));\n        }\n      },\n    );\n\n    return;\n  }\n\n  // Handle static resource caching using patterns defined in the config\n  if (\n    matchesPattern(requestUrl.href, STATE.CONFIG.STATIC_RESOURCE_PATTERN) &&\n    event.request.method === \"GET\" &&\n    !STATE.CONFIG.DISABLE_STATIC_CACHE\n  ) {\n    logger(`Serving static resource from cache: ${event.request.url}`);\n    event.respondWith(staticCacheStrategy.handle(event.request));\n    return;\n  }\n\n  logger(`No cache strategy applied for request: ${event.request.url}`);\n}\n", "import { APICacheStrategy } from \"./cache-strategies/api-cache.strategy\";\nimport { StaticCacheStrategy } from \"./cache-strategies/static-cache.strategy\";\nimport { STATE } from \"./consts\";\nimport { initFetchHandlers } from \"./fetchHandlers\";\nimport { SWConfig } from \"./interfaces/config\";\nimport { PageLoadedEventData } from \"./interfaces/event-data\";\nimport { NotifyAllEventData } from \"./interfaces/notify-data\";\nimport { SwState } from \"./interfaces/state\";\nimport { enableLogger, logger } from \"./logger\";\nimport { swScope } from \"./swScope\";\nimport { sendEvent } from \"./utils\";\n\n/**\n * Initializes the service worker with the provided configuration and sets up event listeners.\n *\n * @param {SWConfig} config - The service worker configuration.\n */\nexport function initServiceWorker(config: SWConfig) {\n  STATE.CONFIG = config;\n\n  // Set defaults\n  STATE.CONFIG.EXCLUDE_PATTERNS = [\n    ...(STATE.CONFIG.EXCLUDE_PATTERNS ?? []),\n    /^chrome-extension:/,\n    /^ws:/,\n    /\\/runtime\\./,\n  ];\n\n  // Initialize caching strategies\n  STATE.STRATEGIES.apiCache = new APICacheStrategy(\n    STATE.CONFIG.CACHE_NAME_API,\n    STATE.CACHE_LIST,\n    STATE.CONFIG,\n  );\n  STATE.STRATEGIES.staticCache = new StaticCacheStrategy(\n    STATE.CONFIG.CACHE_NAME_STATIC,\n  );\n\n  if (config.debug) {\n    enableLogger();\n  }\n\n  initFetchHandlers(STATE.STRATEGIES);\n  setupInstallListener();\n  setupActivateListener(STATE);\n  setupMessageListener(STATE); // Passing config to message listener directly\n}\n\n/**\n * Sets up the install event listener to skip waiting and activate immediately.\n */\nfunction setupInstallListener() {\n  swScope.addEventListener(\"install\", () => {\n    swScope.skipWaiting();\n    logger(\"Service worker installed and skipped waiting.\");\n  });\n}\n\n/**\n * Sets up the activate event listener to claim clients and clear the API cache.\n */\nfunction setupActivateListener(state: SwState) {\n  swScope.addEventListener(\"activate\", (event) => {\n    event.waitUntil(\n      Promise.all([swScope.clients.claim(), state.STRATEGIES.apiCache.clear()]),\n    );\n    logger(\"Activated service worker and claimed clients.\");\n  });\n}\n\n/**\n * Sets up the message event listener to handle specific actions like page load and notifications.\n *\n * @param {SwState} state - The service worker state.\n */\nfunction setupMessageListener(state: SwState) {\n  swScope.addEventListener(\n    \"message\",\n    (event: { data: PageLoadedEventData | NotifyAllEventData }) => {\n      const action = event.data.action;\n      logger(\"Received message action:\", action);\n\n      switch (action) {\n        case \"pageLoaded\":\n          handlePageLoaded(event.data as PageLoadedEventData, state);\n          break;\n        case \"notifyAll\":\n          sendEvent((event.data as NotifyAllEventData).event);\n          break;\n        default:\n          logger(\"Unhandled message action:\", action);\n      }\n    },\n  );\n}\n\n/**\n * Handles the \"pageLoaded\" action, updates the service worker configuration, and caches static resources.\n *\n * @param {PageLoadedEventData} data - The data associated with the page load event.\n * @param {SwState} state - The service worker state.\n */\nfunction handlePageLoaded(data: PageLoadedEventData, state: SwState) {\n  state.CONFIG.APP_VERSION = data.version;\n\n  if (state.CONFIG.DISABLE_STATIC_CACHE) {\n    state.STRATEGIES.staticCache.clear();\n  }\n\n  state.STRATEGIES.apiCache.clear();\n}\n", "import { initServiceWorker } from \"./eventListeners\";\nimport { SWConfig } from \"./interfaces/config\";\n\n// TODO: add some configuration for define consts and setup SW\nconst CONFIG: SWConfig = {\n  debug: true,\n  APP_VERSION: \"0.0.1\",\n  CACHE_NAME_STATIC: \"static-cache\",\n  CACHE_NAME_API: \"api-cache\",\n  CACHE_USE_CACHE_NAME: \"Sw-Use-Cache\",\n  CACHE_IGNORE_NAME: \"Sw-Cache-Ignore\",\n  CACHE_HEADER_NAME: \"Sw-Cache-Name\",\n  CACHE_TTL_NAME: \"Sw-Cache-Ttl\",\n  CACHE_DELETE_NAME: \"Sw-Cache-Update-For\",\n  DISABLE_STATIC_CACHE: false,\n  DISABLE_DYNAMIC_CACHE: false,\n  STATIC_RESOURCE_PATTERN: [\n    /\\.js$/,\n    /\\.css$/,\n    /\\/assets\\//,\n    /\\/translations\\//,\n  ],\n  EXCLUDE_PATTERNS: [/^chrome-extension:/, /^ws:/, /\\/runtime\\./],\n  API_PATTERNS: [/\\/api\\//],\n};\n\ninitServiceWorker(CONFIG);\n"],
  "mappings": "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",
  "names": []
}

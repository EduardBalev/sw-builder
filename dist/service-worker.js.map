{
  "version": 3,
  "sources": ["../src/consts.ts", "../src/logger.ts", "../src/swScope.ts", "../src/utils.ts", "../src/cache.ts", "../src/eventListeners.ts", "../src/fetchHandlers.ts", "../src/service-worker.ts"],
  "sourcesContent": ["import { SwCache } from \"./interfaces/cache\";\nimport { SwState } from \"./interfaces/state\";\n\n/**\n * The state object of the service worker, holding the configuration, static resource patterns, and cache entries.\n *\n * @constant {SwState} STATE\n */\nexport const STATE: SwState = {\n  CONFIG: null,\n  STATIC_RESOURCE_PATTERN: new RegExp(\"\"),\n  CACHE_LIST: new Map<string, SwCache>(),\n};\n", "let __loggerIsEnabled = false;\n\n/**\n * Enables the logger, allowing logs to be printed to the console.\n */\nexport function enableLogger() {\n  __loggerIsEnabled = true;\n}\n\n/**\n * Disables the logger, preventing logs from being printed to the console.\n */\nexport function disableLogger() {\n  __loggerIsEnabled = false;\n}\n\n/**\n * Logs the provided data to the console if logging is enabled.\n *\n * @param {...unknown[]} data - The data to be logged.\n */\nexport function logger(...data: unknown[]) {\n  if (__loggerIsEnabled) {\n    console.log(...data);\n  }\n}\n", "/// <reference lib=\"webworker\" />\n\n/**\n * Casts the global `self` object to the `ServiceWorkerGlobalScope` type.\n *\n * In TypeScript, the `self` object, which represents the global scope in a service worker, is by default typed as `Window & typeof globalThis`.\n * This means that TypeScript will treat `self` as a standard window object, not as a service worker global scope. To use service worker-specific\n * properties like `clients`, `skipWaiting()`, or event listeners such as `onfetch`, we need to cast `self` to the correct type.\n *\n * This ensures that the service worker-specific APIs and properties are available in a type-safe manner without TypeScript errors.\n *\n * @constant {ServiceWorkerGlobalScope} swScope - A correctly typed reference to the service worker's global scope.\n */\nexport const swScope = self as unknown as ServiceWorkerGlobalScope;\n", "import { SwCacheList } from \"./interfaces/cache\";\nimport { SWConfig } from \"./interfaces/config\";\nimport { NotifyData } from \"./interfaces/notify-data\";\nimport { logger } from \"./logger\";\nimport { swScope } from \"./swScope\";\n\n/**\n * Retrieves the value of a specific header from a given request.\n *\n * @param {Request} request - The request object containing headers.\n * @param {string} headerName - The name of the header to retrieve.\n * @returns {string | null} The value of the specified header, or null if the header is not found.\n */\nexport function getRequestHeader(\n  request: Request,\n  headerName: string,\n): string | null {\n  return request?.headers?.get(toCapitalizedString(headerName));\n}\n\n/**\n * Sends a specified event to all connected clients (e.g., browser tabs or windows controlled by the service worker).\n *\n * @param {NotifyData} event - The event data to be sent to each connected client.\n */\nexport async function sendEvent(event: NotifyData) {\n  // Log the event that is being sent\n  logger(\"Sending event from Service Worker: \", event);\n\n  try {\n    // Get all connected clients (e.g., browser tabs or windows controlled by the service worker)\n    const clients = await swScope.clients.matchAll();\n\n    logger(`Found ${clients.length} clients to send the event to.`);\n\n    // Send the event to each client\n    for (let i = 0; i < clients.length; i++) {\n      logger(`Sending event to client: ${clients[i].id}`);\n      clients[i].postMessage(event);\n    }\n\n    logger(\"Event sent to all clients.\");\n  } catch (error) {\n    logger(\"Error sending event to clients:\", error);\n  }\n}\n\n/**\n * Processes cacheable requests by checking headers and updating the cache if needed.\n *\n * @param {Request} request - The network request to check for cacheability.\n * @param {SwCacheList} cache - The cache list to store and update cache entries.\n * @param {SWConfig} config - The configuration containing header names and cache settings.\n * @returns {Promise<void>} A promise that resolves after processing the cache logic.\n */\nexport async function catchCashableRequests(\n  request: Request,\n  cache: SwCacheList,\n  config: SWConfig,\n): Promise<void> {\n  // Cache header values to avoid repeated lookups\n  const useCache = request.headers.get(config.CACHE_USE_CACHE_NAME);\n  const name = request.headers.get(config.CACHE_HEADER_NAME);\n  const ttl = request.headers.get(config.CACHE_TTL_NAME);\n  const updateFor = request.headers.get(config.CACHE_DELETE_NAME);\n\n  // Logging initial check for cache usage\n  logger(`Checking if request should use cache: ${useCache}`);\n\n  // If caching is not enabled, return early\n  if (useCache !== \"true\") {\n    logger(`Caching not enabled for this request.`);\n    return;\n  }\n\n  logger(`Processing request for cacheable content.`);\n\n  // Add new cache entry if not already present\n  if (name && !cache.has(name)) {\n    cache.set(name, {\n      name,\n      ttl: Number(ttl), // Convert ttl to a number\n    });\n    logger(`Cache entry added: ${name} with TTL: ${ttl}`);\n  } else if (name) {\n    logger(`Cache entry for ${name} already exists.`);\n  }\n\n  // Update specified endpoints if needed\n  if (updateFor) {\n    const names = updateFor.split(\",\");\n\n    if (names.length > 0) {\n      logger(`Updating cache for the following endpoints: ${names}`);\n      await updateEndpoints(names, cache, config);\n    }\n  }\n}\n\n/**\n * Updates the cache entries by setting the update timestamp and removing expired entries based on provided names.\n *\n * @param {string[]} names - The list of cache entry names to update.\n * @param {SwCacheList} cache - The cache list where the entries are stored.\n * @param {SWConfig} config - The configuration containing cache settings and header names.\n * @returns {Promise<void>} A promise that resolves once all cache entries have been updated and expired entries are deleted.\n */\nexport async function updateEndpoints(\n  names: string[],\n  cache: SwCacheList,\n  config: SWConfig,\n): Promise<void> {\n  const now = Date.now(); // Cache current timestamp to avoid multiple Date object creation\n\n  logger(`Updating endpoints: ${names.join(\", \")}`);\n\n  // Update the timestamp for each endpoint in the cache\n  for (const name of names) {\n    const data = cache.get(name);\n    if (data) {\n      data.updateTimestamp = now;\n      logger(`Updated timestamp for cache entry: ${name}`);\n    } else {\n      logger(`Cache entry not found for: ${name}`);\n    }\n  }\n\n  const cacheInstance = await caches.open(config.CACHE_NAME_API);\n  logger(`Opened cache: ${config.CACHE_NAME_API}`);\n\n  const keys = await cacheInstance.keys(); // Retrieve all cached requests\n  logger(`Retrieved ${keys.length} cached requests`);\n\n  // Delete matching cached requests based on header names\n  const deletePromises = [];\n  for (const req of keys) {\n    const cacheName = req.headers.get(config.CACHE_HEADER_NAME);\n    if (cacheName && names.includes(cacheName)) {\n      logger(`Deleting cache entry for: ${cacheName}`);\n      deletePromises.push(cacheInstance.delete(req));\n    }\n  }\n\n  // Wait for all cache deletions to complete\n  await Promise.all(deletePromises);\n  logger(`Deleted ${deletePromises.length} cache entries`);\n}\n\n/**\n * Fetches a request from the network and caches the response with metadata.\n *\n * @param {Request} request - The network request to fetch.\n * @param {SwCacheList} cache - The cache list where the cache metadata will be stored.\n * @param {SWConfig} config - The configuration containing cache settings and header names.\n * @returns {Promise<Response>} A promise that resolves to the fetched response with cache metadata.\n */\nexport async function fetchAndCache(\n  request: Request,\n  cache: SwCacheList,\n  config: SWConfig,\n): Promise<Response> {\n  try {\n    logger(`Fetching request: ${request.url}`);\n\n    // Fetch the response from the network\n    const response = await fetch(request);\n    const cacheName = getRequestHeader(request, config.CACHE_HEADER_NAME);\n\n    // Check if the response is valid before caching\n    if (!response || response.status !== 200) {\n      logger(\n        `Fetch failed or invalid response for: ${request.url} - Status: ${response?.status}`,\n      );\n      return response;\n    }\n\n    logger(`Fetch successful for: ${request.url}, caching response.`);\n\n    // Get the cache metadata\n    const ttl = cache.get(cacheName)?.ttl || 0;\n    const expiredTimestamp = Date.now() + ttl;\n    const cacheMetadata = { expired: expiredTimestamp };\n\n    // Clone the response to attach metadata\n    const responseWithMetadata = new Response(response.body, {\n      ...response,\n      headers: new Headers(response.headers),\n    });\n\n    // Attach cache metadata to the response headers\n    responseWithMetadata.headers.append(\n      \"X-Cache-Metadata\",\n      JSON.stringify(cacheMetadata),\n    );\n    logger(\n      `Attached cache metadata for: ${request.url}, expires at: ${expiredTimestamp}`,\n    );\n\n    return responseWithMetadata;\n  } catch (error) {\n    logger(`Fetch failed for: ${request.url}`, error);\n    throw error;\n  }\n}\n\n/**\n * Converts any case string to a pattern where only the first letter of the entire string is capitalized\n * and the rest of the string is in lowercase.\n *\n * @param {string} input - The input string to be converted.\n * @returns {string} The formatted string where only the first letter is capitalized.\n */\nfunction toCapitalizedString(input: string): string {\n  return input.charAt(0).toUpperCase() + input.slice(1).toLowerCase();\n}\n", "import { STATE } from \"./consts\";\nimport { logger } from \"./logger\";\nimport { fetchAndCache, updateEndpoints } from \"./utils\";\n\n// TODO: Make better splitting to strategies.\n\nexport async function handleStaticCache(request: Request) {\n  const cache = await caches.open(STATE.CONFIG.CACHE_NAME_STATIC);\n  const cachedResponse = await cache.match(request);\n\n  if (cachedResponse) {\n    logger(\"STATIC Cache hit:\", request.url);\n    return cachedResponse;\n  }\n\n  logger(\"STATIC Cache miss - fetching from network:\", request.url);\n  const networkResponse = await fetch(request);\n  cache.put(request, networkResponse.clone());\n\n  return networkResponse;\n}\n\nexport async function handleAPICache(request: Request, cacheName: string) {\n  const cache = await caches.open(STATE.CONFIG.CACHE_NAME_API);\n  const cachedResponse = await cache.match(request);\n  const meta = STATE.CACHE_LIST.get(cacheName);\n  const now = new Date().getTime();\n  const updateTimestamp = meta?.updateTimestamp ?? now;\n  const isManuallyUpdated = updateTimestamp < now;\n\n  if (cachedResponse && !isManuallyUpdated && !isCacheExpired(cachedResponse)) {\n    logger(\"API Cache hit:\", request.url);\n    return cachedResponse;\n  }\n\n  if (cachedResponse) {\n    cache.delete(request);\n    meta!.updateTimestamp = null;\n  }\n  logger(\"API Cache miss - fetching from network:\", request.url);\n\n  const networkResponse = await fetchAndCache(\n    request,\n    STATE.CACHE_LIST,\n    STATE.CONFIG,\n  );\n  cache.put(request, networkResponse.clone());\n\n  return networkResponse;\n}\n\nexport async function clearAllAPICache() {\n  await caches.delete(STATE.CONFIG.CACHE_NAME_API);\n  await updateEndpoints(\n    Array.from(STATE.CACHE_LIST.keys()),\n    STATE.CACHE_LIST,\n    STATE.CONFIG,\n  );\n  logger(\"Updating all endpoints\");\n}\n\nexport async function clearAllStaticCache() {\n  await caches.delete(STATE.CONFIG.CACHE_NAME_STATIC);\n  logger(\"Cleared static cache\");\n}\n\nfunction isCacheExpired(cachedResponse: Response) {\n  const cachedMetadata = getCachedMetadata(cachedResponse);\n  const currentTime = new Date().getTime();\n  const expiredTime = cachedMetadata?.expired || 0;\n\n  return expiredTime < currentTime;\n}\n\nfunction getCachedMetadata(cachedResponse: Response) {\n  const metadataString = cachedResponse.headers.get(\"X-Cache-Metadata\");\n  return metadataString ? JSON.parse(metadataString) : null;\n}\n", "import { clearAllAPICache, clearAllStaticCache } from \"./cache\";\nimport { STATE } from \"./consts\";\nimport { SWConfig } from \"./interfaces/config\";\nimport { PageLoadedEventData } from \"./interfaces/event-data\";\nimport { NotifyAllEventData } from \"./interfaces/notify-data\";\nimport { enableLogger, logger } from \"./logger\";\nimport { swScope } from \"./swScope\";\nimport { sendEvent } from \"./utils\";\n\n/**\n * Initializes the service worker with the provided configuration and sets up event listeners.\n *\n * @param {SWConfig} config - The service worker configuration.\n */\nexport function initServiceWorker(config: SWConfig) {\n  STATE.CONFIG = config;\n\n  if (config.debug) {\n    enableLogger();\n  }\n\n  setupInstallListener();\n  setupActivateListener();\n  setupMessageListener(config); // Passing config to message listener directly\n}\n\n/**\n * Sets up the install event listener to skip waiting and activate immediately.\n */\nfunction setupInstallListener() {\n  swScope.addEventListener(\"install\", () => {\n    swScope.skipWaiting();\n    logger(\"Service worker installed and skipped waiting.\");\n  });\n}\n\n/**\n * Sets up the activate event listener to claim clients and clear the API cache.\n */\nfunction setupActivateListener() {\n  swScope.addEventListener(\"activate\", (event) => {\n    event.waitUntil(Promise.all([swScope.clients.claim(), clearAllAPICache()]));\n    logger(\"Activated service worker and claimed clients.\");\n  });\n}\n\n/**\n * Sets up the message event listener to handle specific actions like page load and notifications.\n *\n * @param {SWConfig} config - The service worker configuration.\n */\nfunction setupMessageListener(config: SWConfig) {\n  swScope.addEventListener(\n    \"message\",\n    (event: { data: PageLoadedEventData | NotifyAllEventData }) => {\n      const action = event.data.action;\n      logger(\"Received message action:\", action);\n\n      switch (action) {\n        case \"pageLoaded\":\n          handlePageLoaded(event.data as PageLoadedEventData, config);\n          break;\n        case \"notifyAll\":\n          sendEvent((event.data as NotifyAllEventData).event);\n          break;\n        default:\n          logger(\"Unhandled message action:\", action);\n      }\n    },\n  );\n}\n\n/**\n * Handles the \"pageLoaded\" action, updates the service worker configuration, and caches static resources.\n *\n * @param {PageLoadedEventData} data - The data associated with the page load event.\n * @param {SWConfig} config - The service worker configuration.\n */\nfunction handlePageLoaded(data: PageLoadedEventData, config: SWConfig) {\n  const staticPatterns = data.staticPatterns;\n  config.DISABLE_STATIC_CACHE = !!data.disableStaticCache;\n  config.DISABLE_DYNAMIC_CACHE = !!data.disableDynamicCache;\n  config.APP_VERSION = data.version;\n\n  if (staticPatterns && !config.DISABLE_STATIC_CACHE) {\n    logger(`Caching static resources by patterns: ${staticPatterns}`);\n    STATE.STATIC_RESOURCE_PATTERN = new RegExp(\n      staticPatterns.map((regex) => regex.source).join(\"|\"),\n    );\n  }\n\n  if (config.DISABLE_STATIC_CACHE) {\n    clearAllStaticCache();\n  }\n\n  clearAllAPICache();\n}\n", "import { handleAPICache, handleStaticCache } from \"./cache\";\nimport { STATE } from \"./consts\";\nimport { logger } from \"./logger\";\nimport { catchCashableRequests, getRequestHeader } from \"./utils\";\n\n/**\n * Handles the fetch event and applies caching strategies based on the request type.\n *\n * This function intercepts network requests and applies cache logic depending on the\n * request URL, headers, and the service worker's configuration. It handles API caching,\n * static resource caching, and ignores requests that shouldn't be cached.\n *\n * @param {FetchEvent} event - The fetch event triggered by the browser.\n */\nexport function handleFetchEvent(event: FetchEvent) {\n  const requestUrl = new URL(event.request.url);\n  const ignore = getRequestHeader(\n    event.request,\n    STATE.CONFIG.CACHE_IGNORE_NAME,\n  );\n  const cacheName = getRequestHeader(\n    event.request,\n    STATE.CONFIG.CACHE_HEADER_NAME,\n  );\n\n  logger(`Handling fetch event for: ${event.request.url}`);\n\n  // Ignore requests based on the CACHE_IGNORE_NAME header\n  if (ignore) {\n    logger(`Request ignored: ${event.request.url}`);\n    return;\n  }\n\n  // Check if the request is for an HTML page\n  const isHtmlRequest =\n    event.request.headers.get(\"Accept\")?.includes(\"text/html\") ||\n    requestUrl.pathname.endsWith(\".html\");\n\n  // Exclude requests like HTML pages, chrome extensions, or WebSocket connections\n  if (\n    isHtmlRequest ||\n    /^chrome-extension:|^ws:|\\/runtime\\./.test(event.request.url)\n  ) {\n    logger(`Excluded request: ${event.request.url}`);\n    return;\n  }\n\n  // Handle API caching for dynamic content\n  if (\n    requestUrl.pathname.includes(\"/api/\") &&\n    !STATE.CONFIG.DISABLE_DYNAMIC_CACHE\n  ) {\n    logger(`Processing API request: ${event.request.url}`);\n\n    // Use cache strategies for API requests\n    catchCashableRequests(event.request, STATE.CACHE_LIST, STATE.CONFIG).then(\n      () => {\n        if (STATE.CACHE_LIST.has(cacheName)) {\n          logger(`Serving API response from cache: ${cacheName}`);\n          event.respondWith(handleAPICache(event.request, cacheName));\n        }\n      },\n    );\n\n    return;\n  }\n\n  // Handle static resource caching\n  if (\n    STATE.STATIC_RESOURCE_PATTERN.test(event.request.url) &&\n    event.request.method === \"GET\" &&\n    !STATE.CONFIG.DISABLE_STATIC_CACHE\n  ) {\n    logger(`Serving static resource from cache: ${event.request.url}`);\n    event.respondWith(handleStaticCache(event.request));\n    return;\n  }\n\n  logger(`No cache strategy applied for request: ${event.request.url}`);\n}\n", "import { initServiceWorker } from \"./eventListeners\";\nimport { handleFetchEvent } from \"./fetchHandlers\";\nimport { SWConfig } from \"./interfaces/config\";\nimport { swScope } from \"./swScope\";\n\n// TODO: add some configuration for define consts and setup SW\nconst CONFIG: SWConfig = {\n  debug: true,\n  APP_VERSION: \"0.0.1\",\n  CACHE_NAME_STATIC: \"static-cache\",\n  CACHE_NAME_API: \"api-cache\",\n  CACHE_USE_CACHE_NAME: \"Sw-Use-Cache\",\n  CACHE_IGNORE_NAME: \"Sw-Cache-Ignore\",\n  CACHE_HEADER_NAME: \"Sw-Cache-Name\",\n  CACHE_TTL_NAME: \"Sw-Cache-Ttl\",\n  CACHE_DELETE_NAME: \"Sw-Cache-Update-For\",\n  DISABLE_STATIC_CACHE: false,\n  DISABLE_DYNAMIC_CACHE: false,\n};\n\ninitServiceWorker(CONFIG);\n\n/**\n * Adds an event listener to handle fetch events in the service worker.\n */\nswScope.addEventListener(\"fetch\", handleFetchEvent);\n"],
  "mappings": "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",
  "names": []
}
